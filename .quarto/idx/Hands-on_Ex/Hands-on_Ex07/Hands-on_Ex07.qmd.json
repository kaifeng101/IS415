{"title":"Hands-on Exercise 7","markdown":{"yaml":{"title":"Hands-on Exercise 7","subtitle":"Geographical Segmentation with Spatially Constrained Clustering Techniques","author":"Kai Feng","date":"Oct 11, 2024","date-modified":"last-modified","execute":{"eval":true,"echo":true,"freeze":true}},"headingText":"**1.0 Overview**","containsRefs":false,"markdown":"\n\n\nThis exercise focuses on using geographically referenced multivariate data to delineate homogeneous regions. Two major analyses are used:\n\n1.  Hierarchical cluster analysis\n\n2.  Spatially constrained cluster analysis\n\nThe goal is to segment Shan State, Myanmar, into homogeneous regions based on multiple Information and Communication Technology (ICT) indicators: Radio, Television, Landline phone, Mobile phone, Computer, and Internet at home. This approach is commonly applied in geobusiness and spatial policy for defining market or planning areas.\n\n<br/><br/>\n\n# **2.0 Setup**\n\n## 2.1 Installing R-Packages\n\nSpatial data handling\n\n-   **sf**, **rgdal** and **spdep**\n\nAttribute data handling\n\n-   **tidyverse**, especially **readr**, **ggplot2** and **dplyr**\n\nChoropleth mapping\n\n-   **tmap**\n\nMultivariate data visualisation and analysis\n\n-   **coorplot**, **ggpubr**, and **heatmaply**\n\nCluster analysis\n\n-   **cluster** and **ClustGeo**\n\n```{r}\npacman::p_load(spdep, tmap, sf, ClustGeo, \n               ggpubr, cluster, factoextra, NbClust,\n               heatmaply, corrplot, psych, tidyverse, GGally)\n```\n\n<br/>\n\n## 2.2 Data Acquisition\n\nTwo data sets will be used:\n\n-   `Myanmar Township Boundary Data`: a GIS data set in ESRI shapefile format. It consists of township boundary information of Myanmar. The spatial data are captured in polygon features.\n\n-   `Shan-ICT.csv`: an extract of [**The 2014 Myanmar Population and Housing Census Myanmar**](https://myanmar.unfpa.org/en/publications/2014-population-and-housing-census-myanmar-data-sheet) at the township level.\n\n::: panel-tabset\n# **Importing Geospatial Data**\n\n```{r}\nshan_sf <- st_read(dsn = \"data/geospatial\", \n                   layer = \"myanmar_township_boundaries\") %>%\n  filter(ST %in% c(\"Shan (East)\", \"Shan (North)\", \"Shan (South)\")) %>%\n  select(c(2:7))\n\nshan_sf\n\nglimpse(shan_sf)\n```\n\n# Importing Aspatial Data\n\n```{r}\nict <- read_csv (\"data/aspatial/Shan-ICT.csv\")\n\nsummary(ict)\n```\n:::\n\n<br/>\n\n## 2.3 Adding Penetration rate of each ICT\n\n-   Measurement unit: Number of households.\n\n-   Using raw values can introduce bias related to the total number of households.\n\nTownships with a higher total number of households tend to show:\n\n-   Higher numbers of households owning radios, TVs, etc.\n\n-   Potentially inflated ownership rates that don’t reflect actual ownership proportions.\n\nHence:\n\n```{r}\nict_derived <- ict %>%\n  mutate(`RADIO_PR` = `Radio`/`Total households`*1000) %>%\n  mutate(`TV_PR` = `Television`/`Total households`*1000) %>%\n  mutate(`LLPHONE_PR` = `Land line phone`/`Total households`*1000) %>%\n  mutate(`MPHONE_PR` = `Mobile phone`/`Total households`*1000) %>%\n  mutate(`COMPUTER_PR` = `Computer`/`Total households`*1000) %>%\n  mutate(`INTERNET_PR` = `Internet at home`/`Total households`*1000) %>%\n  rename(`DT_PCODE` =`District Pcode`,`DT`=`District Name`,\n         `TS_PCODE`=`Township Pcode`, `TS`=`Township Name`,\n         `TT_HOUSEHOLDS`=`Total households`,\n         `RADIO`=`Radio`, `TV`=`Television`, \n         `LLPHONE`=`Land line phone`, `MPHONE`=`Mobile phone`,\n         `COMPUTER`=`Computer`, `INTERNET`=`Internet at home`) \n\nsummary(ict_derived)\n```\n\n<br/><br/>\n\n# **3.0 Exploratory Data Analysis**\n\n::: callout-note\n**Histogram**\n\nuseful to identify the overall distribution of the data values (i.e. left skew, right skew or normal distribution)\n\n**Box Plot**\n\nuseful to detect if there are outliers\n:::\n\n## Distribution of household with (eg. radio)\n\n::: panel-tabset\n## Histogram\n\n```{r}\nggplot(data=ict_derived, \n       aes(x=`RADIO`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n```\n\n## Box Plot\n\n```{r}\nggplot(data=ict_derived, \n       aes(x=`RADIO`)) +\n  geom_boxplot(color=\"black\", \n               fill=\"light blue\")\n```\n:::\n\n## Distribution of Penetration rate (eg. Radio)\n\n::: panel-tabset\n## Histogram\n\n```{r}\nggplot(data=ict_derived, \n       aes(x=`RADIO_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n```\n\n## Box Plot\n\n```{r}\nggplot(data=ict_derived, \n       aes(x=`RADIO_PR`)) +\n  geom_boxplot(color=\"black\", \n               fill=\"light blue\")\n```\n:::\n\n## Distribution of Penetration Rate across all channels\n\n```{r}\nradio <- ggplot(data=ict_derived, \n             aes(x= `RADIO_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\ntv <- ggplot(data=ict_derived, \n             aes(x= `TV_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\nllphone <- ggplot(data=ict_derived, \n             aes(x= `LLPHONE_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\nmphone <- ggplot(data=ict_derived, \n             aes(x= `MPHONE_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\ncomputer <- ggplot(data=ict_derived, \n             aes(x= `COMPUTER_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\ninternet <- ggplot(data=ict_derived, \n             aes(x= `INTERNET_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\nggarrange(radio, tv, llphone, mphone, computer, internet, \n          ncol = 3, \n          nrow = 2)\n```\n\n::: callout-note\nuse `ggarrange()` to group the histograms together\n:::\n\n## Penetration rate on map\n\n::: panel-tabset\n## Step 1: Join Geo & Aspatial data\n\n```{r}\n#| eval: false\nshan_sf <- left_join(shan_sf, \n                     ict_derived, by=c(\"TS_PCODE\"=\"TS_PCODE\"))\n  \nwrite_rds(shan_sf, \"data/rds/shan_sf.rds\")\n```\n\n```{r}\nshan_sf <- read_rds(\"data/rds/shan_sf.rds\")\n```\n\n## Step 2: Prepare a choropleth map\n\nDistribution of Radio penetration rate of Shan State at township lvl:\n\n```{r}\nqtm(shan_sf, \"RADIO_PR\")\n```\n:::\n\n::: callout-note\nThe above map is bias to the underlying total number of households at the townships. It can be seen from the side by side map visualisation below **\\[Townships with relatively larger number of households are also showing relatively higher number of radio ownership\\]**\n:::\n\n```{r}\nTT_HOUSEHOLDS.map <- tm_shape(shan_sf) + \n  tm_fill(col = \"TT_HOUSEHOLDS\",\n          n = 5,\n          style = \"jenks\", \n          title = \"Total households\") + \n  tm_borders(alpha = 0.5) \n\nRADIO.map <- tm_shape(shan_sf) + \n  tm_fill(col = \"RADIO\",\n          n = 5,\n          style = \"jenks\",\n          title = \"Number Radio \") + \n  tm_borders(alpha = 0.5) \n\ntmap_arrange(TT_HOUSEHOLDS.map, RADIO.map,\n             asp=NA, ncol=2)\n```\n\n## Distribution on penetration rate (eg. radio)\n\n```{r}\ntm_shape(shan_sf) +\n    tm_polygons(c(\"TT_HOUSEHOLDS\", \"RADIO_PR\"),\n                style=\"jenks\") +\n    tm_facets(sync = TRUE, ncol = 2) +\n  tm_legend(legend.position = c(\"right\", \"bottom\"))+\n  tm_layout(outer.margins=0, asp=0)\n```\n\n<br/><br/>\n\n# **4.0 Correlation Analysis**\n\nUse `corrplot.mixed()` to visualise & analyse the correlation of the input variables\n\n```{r}\ncluster_vars.cor = cor(ict_derived[,12:17])\ncorrplot.mixed(cluster_vars.cor,\n         lower = \"ellipse\", \n               upper = \"number\",\n               tl.pos = \"lt\",\n               diag = \"l\",\n               tl.col = \"black\")\n```\n\n::: callout-note\nCOMPUTER_PR and INTERNET_PR are highly correlated\n\nThis suggest that only one of them should be used in the cluster analysis instead of both\n:::\n\n<br/><br/>\n\n# **5.0 Hierarchy Cluster Analysis**\n\n::: panel-tabset\n## Step 1: Extracting clustering variables\n\n```{r}\ncluster_vars <- shan_sf %>%\n  st_set_geometry(NULL) %>%\n  select(\"TS.x\", \"RADIO_PR\", \"TV_PR\", \"LLPHONE_PR\", \"MPHONE_PR\", \"COMPUTER_PR\")\nhead(cluster_vars,10)\n```\n\n::: callout-note\nFollowing 4.0 analysis, we removed INTERNET_RP because it is highly correlated with variable COMPUTER_PR\n:::\n\n**Remove TS.x header:**\n\n```{r}\n# add a new column of towns without header\nrow.names(cluster_vars) <- cluster_vars$\"TS.x\"\nhead(cluster_vars,10)\n\n# remove the old column of towns with \"TS.x\" header\nshan_ict <- select(cluster_vars, c(2:6))\nhead(shan_ict, 10)\n```\n\n## Step 2: Data Standardisation\n\n-   Cluster analysis typically involves multiple variables.\n\n-   It's common for these variables to have different ranges of values.\n\n-   To prevent bias in clustering results towards variables with larger values:\n\n    -   Standardizing input variables is recommended before conducting cluster analysis.\n\n## Step 3: Min-Max VS Z-score standardisation\n\n::: callout-caution\nZ-score standardisation method should only be used if we would assume all variables come from some normal distribution.\n:::\n\n**Min-Max Standardisation**\n\n```{r}\nshan_ict.std <- normalize(shan_ict)\nsummary(shan_ict.std)\n```\n\n::: callout-note\nthe values range of the Min-max standardised clustering variables are 0-1 now\n:::\n\n**Z-score Standardisation**\n\n```{r}\nshan_ict.z <- scale(shan_ict)\ndescribe(shan_ict.z)\n```\n\n::: callout-note\nmean and standard deviation of the Z-score standardised clustering variables are 0 and 1 respectively.\n:::\n:::\n\n### Visualising the standardised clustering variables (radio penetration rate)\n\n::: panel-tabset\n## Histogram\n\n```{r}\nr <- ggplot(data=ict_derived, \n             aes(x= `RADIO_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\") +\n  ggtitle(\"Raw values without standardisation\")\n\nshan_ict_s_df <- as.data.frame(shan_ict.std)\ns <- ggplot(data=shan_ict_s_df, \n       aes(x=`RADIO_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\") +\n  ggtitle(\"Min-Max Standardisation\")\n\nshan_ict_z_df <- as.data.frame(shan_ict.z)\nz <- ggplot(data=shan_ict_z_df, \n       aes(x=`RADIO_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\") +\n  ggtitle(\"Z-score Standardisation\")\n\nggarrange(r, s, z,\n          ncol = 3,\n          nrow = 1)\n```\n\n## Area\n\n```{r}\nr <- ggplot(data=ict_derived, \n             aes(x= `RADIO_PR`)) +\n  geom_density(color=\"black\",\n               fill=\"light blue\") +\n  ggtitle(\"Raw values without standardisation\")\n\nshan_ict_s_df <- as.data.frame(shan_ict.std)\ns <- ggplot(data=shan_ict_s_df, \n       aes(x=`RADIO_PR`)) +\n  geom_density(color=\"black\",\n               fill=\"light blue\") +\n  ggtitle(\"Min-Max Standardisation\")\n\nshan_ict_z_df <- as.data.frame(shan_ict.z)\nz <- ggplot(data=shan_ict_z_df, \n       aes(x=`RADIO_PR`)) +\n  geom_density(color=\"black\",\n               fill=\"light blue\") +\n  ggtitle(\"Z-score Standardisation\")\n\nggarrange(r, s, z,\n          ncol = 3,\n          nrow = 1)\n```\n:::\n\n## Computing proximity matrix\n\n`dist()` supports 6 distance proximity calculations:\n\n**euclidean, maximum, manhattan, canberra, binary and minkowski**. The default is *euclidean* proximity matrix.\n\n```{r}\nproxmat <- dist(shan_ict, method = 'euclidean')\n\nproxmat\n```\n\n## Computing hierarchical clustering\n\n`hclust()` employed agglomeration method to compute the cluster\n\nEight clustering algorithms:\n\n**ward.D, ward.D2, single, complete, average(UPGMA), mcquitty(WPGMA), median(WPGMC) and centroid(UPGMC)**\n\n```{r}\nhclust_ward <- hclust(proxmat, method = 'ward.D')\nplot(hclust_ward, cex = 0.6)\n```\n\n## Selecting the optimal clustering algorithm\n\n-   Identifying stronger clustering structures is a challenge in hierarchical clustering.\n\n-   The `agnes()` function from the `cluster` package can help.\n\n-   Key features of `agnes()`:\n\n    -   Similar to `hclust()`.\n\n    -   Provides the agglomerative coefficient.\n\n-   A coefficient close to 1 indicates a strong clustering structure.\n\n```{r}\nm <- c( \"average\", \"single\", \"complete\", \"ward\")\nnames(m) <- c( \"average\", \"single\", \"complete\", \"ward\")\n\nac <- function(x) {\n  agnes(shan_ict, method = x)$ac\n}\n\nmap_dbl(m, ac)\n```\n\n::: callout-note\nWard’s method provides the strongest clustering structure among the four methods assessed.\n\nHence, in the subsequent analysis, only Ward’s method will be used.\n:::\n\n## Determining Optimal Clusters\n\nAnother technical challenge face by data analyst in performing clustering analysis is to determine the optimal clusters to retain.\n\nThere are [three](https://statweb.stanford.edu/~gwalther/gap) commonly used methods to determine the optimal clusters, they are:\n\n-   [Elbow Method](https://en.wikipedia.org/wiki/Elbow_method_(clustering))\n\n-   [Average Silhouette Method](https://www.sciencedirect.com/science/article/pii/0377042787901257?via%3Dihub)\n\n-   [Gap Statistic Method](http://www.web.stanford.edu/~hastie/Papers/gap.pdf)\n\n#### Gap Statistic Method\n\n-   The gap statistic compares the total variation within clusters for different values of k to their expected values under a random distribution.\n\n-   The optimal number of clusters is the value that maximizes the gap statistic (i.e., produces the largest gap).\n\n-   A larger gap indicates that the clustering structure is significantly different from a random distribution of points.\n\n```{r}\nset.seed(12345)\ngap_stat <- clusGap(shan_ict, \n                    FUN = hcut, \n                    nstart = 25, \n                    K.max = 10, \n                    B = 50)\n# Print the result\nprint(gap_stat, method = \"firstmax\")\n\nfviz_gap_stat(gap_stat)\n```\n\n::: callout-note\nWith reference to the gap statistic graph above, the recommended number of cluster to retain is 1. However, it is not logical to retain only one cluster. By examine the gap statistic graph, the 6-cluster gives the largest gap statistic and should be the next best cluster to pick.\n\n**Note:** In addition to these commonly used approaches, the [NbClust](https://cran.r-project.org/web/packages/NbClust/) package, published by Charrad et al., 2014, provides 30 indices for determining the relevant number of clusters and proposes to users the best clustering scheme from the different results obtained by varying all combinations of number of clusters, distance measures, and clustering methods.\n:::\n\n## Interpreting the dendrograms\n\n-   In the dendrogram, each leaf represents an observation.\n\n-   As we move up, similar observations are grouped into branches, which merge at higher levels.\n\n-   The vertical axis shows the height of fusion, indicating (dis)similarity:\n\n    -   Higher fusion height means less similarity.\n\n-   Proximity can only be assessed based on the height at which branches containing the two observations merge, not their horizontal distance.\n\n-   To highlight selected clusters, use the `rect.hclust()` function in R, specifying border colors with the `border` argument.\n\n```{r}\nplot(hclust_ward, cex = 0.6)\nrect.hclust(hclust_ward, \n            k = 6, \n            border = 2:5)\n```\n\n## Visually-driven hierarchical clustering analysis\n\n```{r}\n# Transforming the data frame into a matrix\nshan_ict_mat <- data.matrix(shan_ict)\n\n# Plotting interactive cluster heatmap using heatmaply()\nheatmaply(normalize(shan_ict_mat),\n          Colv=NA,\n          dist_method = \"euclidean\",\n          hclust_method = \"ward.D\",\n          seriate = \"OLO\",\n          colors = Blues,\n          k_row = 6,\n          margins = c(NA,200,60,NA),\n          fontsize_row = 4,\n          fontsize_col = 5,\n          main=\"Geographic Segmentation of Shan State by ICT indicators\",\n          xlab = \"ICT Indicators\",\n          ylab = \"Townships of Shan State\"\n          )\n```\n\n## Mapping the clusters formed\n\n```{r}\n# Retain only 6 clusters\ngroups <- as.factor(cutree(hclust_ward, k=6))\n\n# The output is called groups. It is a list object.\n\n# In order to visualise the clusters, the groups object need to be appended onto shan_sf simple feature object.\nshan_sf_cluster <- cbind(shan_sf, as.matrix(groups)) %>%\n  rename(`CLUSTER`=`as.matrix.groups.`)\n\n# plot\nqtm(shan_sf_cluster, \"CLUSTER\")\n```\n\n::: callout-note\nThe choropleth map above reveals the clusters are very fragmented. The is one of the major limitation when non-spatial clustering algorithm such as hierarchical cluster analysis method is used.\n:::\n","srcMarkdownNoYaml":"\n\n# **1.0 Overview**\n\nThis exercise focuses on using geographically referenced multivariate data to delineate homogeneous regions. Two major analyses are used:\n\n1.  Hierarchical cluster analysis\n\n2.  Spatially constrained cluster analysis\n\nThe goal is to segment Shan State, Myanmar, into homogeneous regions based on multiple Information and Communication Technology (ICT) indicators: Radio, Television, Landline phone, Mobile phone, Computer, and Internet at home. This approach is commonly applied in geobusiness and spatial policy for defining market or planning areas.\n\n<br/><br/>\n\n# **2.0 Setup**\n\n## 2.1 Installing R-Packages\n\nSpatial data handling\n\n-   **sf**, **rgdal** and **spdep**\n\nAttribute data handling\n\n-   **tidyverse**, especially **readr**, **ggplot2** and **dplyr**\n\nChoropleth mapping\n\n-   **tmap**\n\nMultivariate data visualisation and analysis\n\n-   **coorplot**, **ggpubr**, and **heatmaply**\n\nCluster analysis\n\n-   **cluster** and **ClustGeo**\n\n```{r}\npacman::p_load(spdep, tmap, sf, ClustGeo, \n               ggpubr, cluster, factoextra, NbClust,\n               heatmaply, corrplot, psych, tidyverse, GGally)\n```\n\n<br/>\n\n## 2.2 Data Acquisition\n\nTwo data sets will be used:\n\n-   `Myanmar Township Boundary Data`: a GIS data set in ESRI shapefile format. It consists of township boundary information of Myanmar. The spatial data are captured in polygon features.\n\n-   `Shan-ICT.csv`: an extract of [**The 2014 Myanmar Population and Housing Census Myanmar**](https://myanmar.unfpa.org/en/publications/2014-population-and-housing-census-myanmar-data-sheet) at the township level.\n\n::: panel-tabset\n# **Importing Geospatial Data**\n\n```{r}\nshan_sf <- st_read(dsn = \"data/geospatial\", \n                   layer = \"myanmar_township_boundaries\") %>%\n  filter(ST %in% c(\"Shan (East)\", \"Shan (North)\", \"Shan (South)\")) %>%\n  select(c(2:7))\n\nshan_sf\n\nglimpse(shan_sf)\n```\n\n# Importing Aspatial Data\n\n```{r}\nict <- read_csv (\"data/aspatial/Shan-ICT.csv\")\n\nsummary(ict)\n```\n:::\n\n<br/>\n\n## 2.3 Adding Penetration rate of each ICT\n\n-   Measurement unit: Number of households.\n\n-   Using raw values can introduce bias related to the total number of households.\n\nTownships with a higher total number of households tend to show:\n\n-   Higher numbers of households owning radios, TVs, etc.\n\n-   Potentially inflated ownership rates that don’t reflect actual ownership proportions.\n\nHence:\n\n```{r}\nict_derived <- ict %>%\n  mutate(`RADIO_PR` = `Radio`/`Total households`*1000) %>%\n  mutate(`TV_PR` = `Television`/`Total households`*1000) %>%\n  mutate(`LLPHONE_PR` = `Land line phone`/`Total households`*1000) %>%\n  mutate(`MPHONE_PR` = `Mobile phone`/`Total households`*1000) %>%\n  mutate(`COMPUTER_PR` = `Computer`/`Total households`*1000) %>%\n  mutate(`INTERNET_PR` = `Internet at home`/`Total households`*1000) %>%\n  rename(`DT_PCODE` =`District Pcode`,`DT`=`District Name`,\n         `TS_PCODE`=`Township Pcode`, `TS`=`Township Name`,\n         `TT_HOUSEHOLDS`=`Total households`,\n         `RADIO`=`Radio`, `TV`=`Television`, \n         `LLPHONE`=`Land line phone`, `MPHONE`=`Mobile phone`,\n         `COMPUTER`=`Computer`, `INTERNET`=`Internet at home`) \n\nsummary(ict_derived)\n```\n\n<br/><br/>\n\n# **3.0 Exploratory Data Analysis**\n\n::: callout-note\n**Histogram**\n\nuseful to identify the overall distribution of the data values (i.e. left skew, right skew or normal distribution)\n\n**Box Plot**\n\nuseful to detect if there are outliers\n:::\n\n## Distribution of household with (eg. radio)\n\n::: panel-tabset\n## Histogram\n\n```{r}\nggplot(data=ict_derived, \n       aes(x=`RADIO`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n```\n\n## Box Plot\n\n```{r}\nggplot(data=ict_derived, \n       aes(x=`RADIO`)) +\n  geom_boxplot(color=\"black\", \n               fill=\"light blue\")\n```\n:::\n\n## Distribution of Penetration rate (eg. Radio)\n\n::: panel-tabset\n## Histogram\n\n```{r}\nggplot(data=ict_derived, \n       aes(x=`RADIO_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n```\n\n## Box Plot\n\n```{r}\nggplot(data=ict_derived, \n       aes(x=`RADIO_PR`)) +\n  geom_boxplot(color=\"black\", \n               fill=\"light blue\")\n```\n:::\n\n## Distribution of Penetration Rate across all channels\n\n```{r}\nradio <- ggplot(data=ict_derived, \n             aes(x= `RADIO_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\ntv <- ggplot(data=ict_derived, \n             aes(x= `TV_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\nllphone <- ggplot(data=ict_derived, \n             aes(x= `LLPHONE_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\nmphone <- ggplot(data=ict_derived, \n             aes(x= `MPHONE_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\ncomputer <- ggplot(data=ict_derived, \n             aes(x= `COMPUTER_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\ninternet <- ggplot(data=ict_derived, \n             aes(x= `INTERNET_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\nggarrange(radio, tv, llphone, mphone, computer, internet, \n          ncol = 3, \n          nrow = 2)\n```\n\n::: callout-note\nuse `ggarrange()` to group the histograms together\n:::\n\n## Penetration rate on map\n\n::: panel-tabset\n## Step 1: Join Geo & Aspatial data\n\n```{r}\n#| eval: false\nshan_sf <- left_join(shan_sf, \n                     ict_derived, by=c(\"TS_PCODE\"=\"TS_PCODE\"))\n  \nwrite_rds(shan_sf, \"data/rds/shan_sf.rds\")\n```\n\n```{r}\nshan_sf <- read_rds(\"data/rds/shan_sf.rds\")\n```\n\n## Step 2: Prepare a choropleth map\n\nDistribution of Radio penetration rate of Shan State at township lvl:\n\n```{r}\nqtm(shan_sf, \"RADIO_PR\")\n```\n:::\n\n::: callout-note\nThe above map is bias to the underlying total number of households at the townships. It can be seen from the side by side map visualisation below **\\[Townships with relatively larger number of households are also showing relatively higher number of radio ownership\\]**\n:::\n\n```{r}\nTT_HOUSEHOLDS.map <- tm_shape(shan_sf) + \n  tm_fill(col = \"TT_HOUSEHOLDS\",\n          n = 5,\n          style = \"jenks\", \n          title = \"Total households\") + \n  tm_borders(alpha = 0.5) \n\nRADIO.map <- tm_shape(shan_sf) + \n  tm_fill(col = \"RADIO\",\n          n = 5,\n          style = \"jenks\",\n          title = \"Number Radio \") + \n  tm_borders(alpha = 0.5) \n\ntmap_arrange(TT_HOUSEHOLDS.map, RADIO.map,\n             asp=NA, ncol=2)\n```\n\n## Distribution on penetration rate (eg. radio)\n\n```{r}\ntm_shape(shan_sf) +\n    tm_polygons(c(\"TT_HOUSEHOLDS\", \"RADIO_PR\"),\n                style=\"jenks\") +\n    tm_facets(sync = TRUE, ncol = 2) +\n  tm_legend(legend.position = c(\"right\", \"bottom\"))+\n  tm_layout(outer.margins=0, asp=0)\n```\n\n<br/><br/>\n\n# **4.0 Correlation Analysis**\n\nUse `corrplot.mixed()` to visualise & analyse the correlation of the input variables\n\n```{r}\ncluster_vars.cor = cor(ict_derived[,12:17])\ncorrplot.mixed(cluster_vars.cor,\n         lower = \"ellipse\", \n               upper = \"number\",\n               tl.pos = \"lt\",\n               diag = \"l\",\n               tl.col = \"black\")\n```\n\n::: callout-note\nCOMPUTER_PR and INTERNET_PR are highly correlated\n\nThis suggest that only one of them should be used in the cluster analysis instead of both\n:::\n\n<br/><br/>\n\n# **5.0 Hierarchy Cluster Analysis**\n\n::: panel-tabset\n## Step 1: Extracting clustering variables\n\n```{r}\ncluster_vars <- shan_sf %>%\n  st_set_geometry(NULL) %>%\n  select(\"TS.x\", \"RADIO_PR\", \"TV_PR\", \"LLPHONE_PR\", \"MPHONE_PR\", \"COMPUTER_PR\")\nhead(cluster_vars,10)\n```\n\n::: callout-note\nFollowing 4.0 analysis, we removed INTERNET_RP because it is highly correlated with variable COMPUTER_PR\n:::\n\n**Remove TS.x header:**\n\n```{r}\n# add a new column of towns without header\nrow.names(cluster_vars) <- cluster_vars$\"TS.x\"\nhead(cluster_vars,10)\n\n# remove the old column of towns with \"TS.x\" header\nshan_ict <- select(cluster_vars, c(2:6))\nhead(shan_ict, 10)\n```\n\n## Step 2: Data Standardisation\n\n-   Cluster analysis typically involves multiple variables.\n\n-   It's common for these variables to have different ranges of values.\n\n-   To prevent bias in clustering results towards variables with larger values:\n\n    -   Standardizing input variables is recommended before conducting cluster analysis.\n\n## Step 3: Min-Max VS Z-score standardisation\n\n::: callout-caution\nZ-score standardisation method should only be used if we would assume all variables come from some normal distribution.\n:::\n\n**Min-Max Standardisation**\n\n```{r}\nshan_ict.std <- normalize(shan_ict)\nsummary(shan_ict.std)\n```\n\n::: callout-note\nthe values range of the Min-max standardised clustering variables are 0-1 now\n:::\n\n**Z-score Standardisation**\n\n```{r}\nshan_ict.z <- scale(shan_ict)\ndescribe(shan_ict.z)\n```\n\n::: callout-note\nmean and standard deviation of the Z-score standardised clustering variables are 0 and 1 respectively.\n:::\n:::\n\n### Visualising the standardised clustering variables (radio penetration rate)\n\n::: panel-tabset\n## Histogram\n\n```{r}\nr <- ggplot(data=ict_derived, \n             aes(x= `RADIO_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\") +\n  ggtitle(\"Raw values without standardisation\")\n\nshan_ict_s_df <- as.data.frame(shan_ict.std)\ns <- ggplot(data=shan_ict_s_df, \n       aes(x=`RADIO_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\") +\n  ggtitle(\"Min-Max Standardisation\")\n\nshan_ict_z_df <- as.data.frame(shan_ict.z)\nz <- ggplot(data=shan_ict_z_df, \n       aes(x=`RADIO_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\") +\n  ggtitle(\"Z-score Standardisation\")\n\nggarrange(r, s, z,\n          ncol = 3,\n          nrow = 1)\n```\n\n## Area\n\n```{r}\nr <- ggplot(data=ict_derived, \n             aes(x= `RADIO_PR`)) +\n  geom_density(color=\"black\",\n               fill=\"light blue\") +\n  ggtitle(\"Raw values without standardisation\")\n\nshan_ict_s_df <- as.data.frame(shan_ict.std)\ns <- ggplot(data=shan_ict_s_df, \n       aes(x=`RADIO_PR`)) +\n  geom_density(color=\"black\",\n               fill=\"light blue\") +\n  ggtitle(\"Min-Max Standardisation\")\n\nshan_ict_z_df <- as.data.frame(shan_ict.z)\nz <- ggplot(data=shan_ict_z_df, \n       aes(x=`RADIO_PR`)) +\n  geom_density(color=\"black\",\n               fill=\"light blue\") +\n  ggtitle(\"Z-score Standardisation\")\n\nggarrange(r, s, z,\n          ncol = 3,\n          nrow = 1)\n```\n:::\n\n## Computing proximity matrix\n\n`dist()` supports 6 distance proximity calculations:\n\n**euclidean, maximum, manhattan, canberra, binary and minkowski**. The default is *euclidean* proximity matrix.\n\n```{r}\nproxmat <- dist(shan_ict, method = 'euclidean')\n\nproxmat\n```\n\n## Computing hierarchical clustering\n\n`hclust()` employed agglomeration method to compute the cluster\n\nEight clustering algorithms:\n\n**ward.D, ward.D2, single, complete, average(UPGMA), mcquitty(WPGMA), median(WPGMC) and centroid(UPGMC)**\n\n```{r}\nhclust_ward <- hclust(proxmat, method = 'ward.D')\nplot(hclust_ward, cex = 0.6)\n```\n\n## Selecting the optimal clustering algorithm\n\n-   Identifying stronger clustering structures is a challenge in hierarchical clustering.\n\n-   The `agnes()` function from the `cluster` package can help.\n\n-   Key features of `agnes()`:\n\n    -   Similar to `hclust()`.\n\n    -   Provides the agglomerative coefficient.\n\n-   A coefficient close to 1 indicates a strong clustering structure.\n\n```{r}\nm <- c( \"average\", \"single\", \"complete\", \"ward\")\nnames(m) <- c( \"average\", \"single\", \"complete\", \"ward\")\n\nac <- function(x) {\n  agnes(shan_ict, method = x)$ac\n}\n\nmap_dbl(m, ac)\n```\n\n::: callout-note\nWard’s method provides the strongest clustering structure among the four methods assessed.\n\nHence, in the subsequent analysis, only Ward’s method will be used.\n:::\n\n## Determining Optimal Clusters\n\nAnother technical challenge face by data analyst in performing clustering analysis is to determine the optimal clusters to retain.\n\nThere are [three](https://statweb.stanford.edu/~gwalther/gap) commonly used methods to determine the optimal clusters, they are:\n\n-   [Elbow Method](https://en.wikipedia.org/wiki/Elbow_method_(clustering))\n\n-   [Average Silhouette Method](https://www.sciencedirect.com/science/article/pii/0377042787901257?via%3Dihub)\n\n-   [Gap Statistic Method](http://www.web.stanford.edu/~hastie/Papers/gap.pdf)\n\n#### Gap Statistic Method\n\n-   The gap statistic compares the total variation within clusters for different values of k to their expected values under a random distribution.\n\n-   The optimal number of clusters is the value that maximizes the gap statistic (i.e., produces the largest gap).\n\n-   A larger gap indicates that the clustering structure is significantly different from a random distribution of points.\n\n```{r}\nset.seed(12345)\ngap_stat <- clusGap(shan_ict, \n                    FUN = hcut, \n                    nstart = 25, \n                    K.max = 10, \n                    B = 50)\n# Print the result\nprint(gap_stat, method = \"firstmax\")\n\nfviz_gap_stat(gap_stat)\n```\n\n::: callout-note\nWith reference to the gap statistic graph above, the recommended number of cluster to retain is 1. However, it is not logical to retain only one cluster. By examine the gap statistic graph, the 6-cluster gives the largest gap statistic and should be the next best cluster to pick.\n\n**Note:** In addition to these commonly used approaches, the [NbClust](https://cran.r-project.org/web/packages/NbClust/) package, published by Charrad et al., 2014, provides 30 indices for determining the relevant number of clusters and proposes to users the best clustering scheme from the different results obtained by varying all combinations of number of clusters, distance measures, and clustering methods.\n:::\n\n## Interpreting the dendrograms\n\n-   In the dendrogram, each leaf represents an observation.\n\n-   As we move up, similar observations are grouped into branches, which merge at higher levels.\n\n-   The vertical axis shows the height of fusion, indicating (dis)similarity:\n\n    -   Higher fusion height means less similarity.\n\n-   Proximity can only be assessed based on the height at which branches containing the two observations merge, not their horizontal distance.\n\n-   To highlight selected clusters, use the `rect.hclust()` function in R, specifying border colors with the `border` argument.\n\n```{r}\nplot(hclust_ward, cex = 0.6)\nrect.hclust(hclust_ward, \n            k = 6, \n            border = 2:5)\n```\n\n## Visually-driven hierarchical clustering analysis\n\n```{r}\n# Transforming the data frame into a matrix\nshan_ict_mat <- data.matrix(shan_ict)\n\n# Plotting interactive cluster heatmap using heatmaply()\nheatmaply(normalize(shan_ict_mat),\n          Colv=NA,\n          dist_method = \"euclidean\",\n          hclust_method = \"ward.D\",\n          seriate = \"OLO\",\n          colors = Blues,\n          k_row = 6,\n          margins = c(NA,200,60,NA),\n          fontsize_row = 4,\n          fontsize_col = 5,\n          main=\"Geographic Segmentation of Shan State by ICT indicators\",\n          xlab = \"ICT Indicators\",\n          ylab = \"Townships of Shan State\"\n          )\n```\n\n## Mapping the clusters formed\n\n```{r}\n# Retain only 6 clusters\ngroups <- as.factor(cutree(hclust_ward, k=6))\n\n# The output is called groups. It is a list object.\n\n# In order to visualise the clusters, the groups object need to be appended onto shan_sf simple feature object.\nshan_sf_cluster <- cbind(shan_sf, as.matrix(groups)) %>%\n  rename(`CLUSTER`=`as.matrix.groups.`)\n\n# plot\nqtm(shan_sf_cluster, \"CLUSTER\")\n```\n\n::: callout-note\nThe choropleth map above reveals the clusters are very fragmented. The is one of the major limitation when non-spatial clustering algorithm such as hierarchical cluster analysis method is used.\n:::\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"output-file":"Hands-on_Ex07.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.555","editor":"visual","theme":"cosmo","title":"Hands-on Exercise 7","subtitle":"Geographical Segmentation with Spatially Constrained Clustering Techniques","author":"Kai Feng","date":"Oct 11, 2024","date-modified":"last-modified"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}