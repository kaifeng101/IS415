{"title":"Hands-on Exercise 8","markdown":{"yaml":{"title":"Hands-on Exercise 8","subtitle":"Geographical Segmentation with Spatially Constrained Clustering Techniques (Continuation of Hands-on Exercise 7)","author":"Kai Feng","date":"Oct 19, 2024","date-modified":"last-modified","execute":{"eval":true,"echo":true,"freeze":true}},"headingText":"**1.0 Overview**","containsRefs":false,"markdown":"\n\n\nThis exercise focuses on using geographically referenced multivariate data to delineate homogeneous regions. Two major analyses are used:\n\n1.  Hierarchical cluster analysis\n\n2.  Spatially constrained cluster analysis\n\nThe goal is to segment Shan State, Myanmar, into homogeneous regions based on multiple Information and Communication Technology (ICT) indicators: Radio, Television, Landline phone, Mobile phone, Computer, and Internet at home. This approach is commonly applied in geobusiness and spatial policy for defining market or planning areas.\n\n<br/><br/>\n\n# **2.0 Setup**\n\n## 2.1 Installing R-Packages\n\nSpatial data handling\n\n-   **sf**, **rgdal** and **spdep**\n\nAttribute data handling\n\n-   **tidyverse**, especially **readr**, **ggplot2** and **dplyr**\n\nChoropleth mapping\n\n-   **tmap**\n\nMultivariate data visualisation and analysis\n\n-   **coorplot**, **ggpubr**, and **heatmaply**\n\nCluster analysis\n\n-   **cluster** and **ClustGeo**\n\n```{r}\npacman::p_load(spdep, tmap, sf, ClustGeo, \n               ggpubr, cluster, factoextra, NbClust,\n               heatmaply, corrplot, psych, tidyverse, GGally)\n```\n\n<br/>\n\n## 2.2 Data Acquisition\n\nTwo data sets will be used:\n\n-   `Myanmar Township Boundary Data`: a GIS data set in ESRI shapefile format. It consists of township boundary information of Myanmar. The spatial data are captured in polygon features.\n\n-   `Shan-ICT.csv`: an extract of [**The 2014 Myanmar Population and Housing Census Myanmar**](https://myanmar.unfpa.org/en/publications/2014-population-and-housing-census-myanmar-data-sheet) at the township level.\n\n::: panel-tabset\n# **Importing Geospatial Data**\n\n```{r}\nshan_sf <- st_read(dsn = \"data/geospatial\", \n                   layer = \"myanmar_township_boundaries\") %>%\n  filter(ST %in% c(\"Shan (East)\", \"Shan (North)\", \"Shan (South)\")) %>%\n  select(c(2:7))\n\nshan_sf\n\nglimpse(shan_sf)\n```\n\n# Importing Aspatial Data\n\n```{r}\nict <- read_csv (\"data/aspatial/Shan-ICT.csv\")\n\nsummary(ict)\n```\n:::\n\n<br/><br/>\n\n# **3.0 Spatially Constrained Clustering: SKATER approach**\n\n```{r}\n# Convert into SpatialPolygonsDataFrame\nshan_sp <- as_Spatial(shan_sf)\n```\n\n::: callout-note\nConvert because *`SKATER`* only supports sp obects like SpatialPolygonsDataFrame\n:::\n\n::: panel-tabset\n## Computing Neighbour List\n\n```{r}\nshan.nb <- poly2nb(shan_sp)\nsummary(shan.nb)\n```\n\n**Plot neighbours list**\n\n```{r}\ncoords <- st_coordinates(\n  st_centroid(st_geometry(shan_sf)))\n\nplot(st_geometry(shan_sf), # boundaries\n     border=grey(.5))\nplot(shan.nb, # neighbour list object, with coordinates applied to the original SpatialPolygonDataFrame (Shan state township boundaries) to extract the centroids of the polygons. These are used as the nodes for the graph representation. \n     coords, \n     col=\"blue\", \n     add=TRUE) # in order to plot the network on top of the boundaries\n```\n\n::: callout-note\nIf plot network first, some areas will be clipped.\n\nBecause the plotting area is determined by the characteristics of the first plot.\n\nIn this example, the boundary map extends further than the graph, so plot boundary first.\n:::\n\n## Computing minimum spanning tree\n\nTo calculate edge cost (distance between nodes):\n\n```{r}\nshan_ict <- read_rds(\"data/rds/shan_ict.rds\")\n\nlcosts <- nbcosts(shan.nb, shan_ict)\nhead(lcosts)\n```\n\n::: callout-note\nEach observation gives pairwise dissimilarity between its values on the 5 variables & the values for the neighbouring observation (from the neighbour list.\n\nBasically this is the notion of a generalised weight for a spatial weights matrix\n:::\n\n<br/>\n\n-   Incorporate these costs into a weighted neighbor list.\n\n-   Convert the neighbor list to a weights object using the computed `lcosts` as weights.\n\n```{r}\nshan.w <- nb2listw(shan.nb, \n                   lcosts, \n                   style=\"B\") # to make sure the cost values are not row-standardised\nsummary(shan.w)\n```\n\n## Computing minimum spanning tree\n\n-   Computed by mean of mstree()\n\n```{r}\nshan.mst <- mstree(shan.w)\nclass(shan.mst)\ndim(shan.mst)\nhead(shan.mst)\n```\n\n::: callout-note\nThe dimension is 54 not 55. Because the min spanning tree consists on n-1 edges (links) in order to traverse all the nodes\n:::\n\n**Plot MST**\n\n```{r}\nplot(st_geometry(shan_sf), \n                 border=gray(.5))\nplot.mst(shan.mst, \n         coords, \n         col=\"blue\", \n         cex.lab=0.7, \n         cex.circles=0.005, \n         add=TRUE)\n```\n\n::: callout-note\nWe can see how the initial neighbour list is simplified to just 1 edge connecting each of the nodes while passing through all the nodes\n:::\n\n## Computing spatially constrained clusters using SKATER method\n\n```{r}\nclust6 <- spdep::skater(edges = shan.mst[,1:2], \n                 data = shan_ict, \n                 method = \"euclidean\", \n                 ncuts = 5)\nstr(clust6)\n```\n\n::: callout-note\nThe *skater()* takes three mandatory arguments: - the first two columns of the MST matrix (i.e. not the cost), - the data matrix (to update the costs as units are being grouped), and - the number of cuts. Note: It is set to **one less than the number of clusters**. So, the value specified is **not** the number of clusters, but the number of cuts in the graph, one less than the number of clusters.\n\nThe most interesting component of this list structure is the groups vector containing the labels of the cluster to which each observation belongs (as before, the label itself is arbitary). This is followed by a detailed summary for each of the clusters in the edges.groups list. Sum of squares measures are given as ssto for the total and ssw to show the effect of each of the cuts on the overall criterion.\n:::\n\n**Check cluster assignment:**\n\n```{r}\nccs6 <- clust6$groups\nccs6\n\ntable(ccs6)\n```\n\n::: callout-note\nWe can find out how many observations are in each cluster by means of the table command. Parenthetially, we can also find this as the dimension of each vector in the lists contained in edges.groups. For example, the first list has node with dimension 12, which is also the number of observations in the first cluster.\n:::\n\n**Plot the pruned tree that shows 5 clusters on top of townshop area**\n\n```{r}\nplot(st_geometry(shan_sf), \n     border=gray(.5))\nplot(clust6, \n     coords, \n     cex.lab=.7,\n     groups.colors=c(\"red\",\"green\",\"blue\", \"brown\", \"pink\"),\n     cex.circles=0.005, \n     add=TRUE)\n```\n\n**Visualising the clusters in choropleth map**\n\n```{r}\nshan_sf_cluster  <- read_rds(\"data/rds/shan_sf_cluster.rds\")\n\ngroups_mat <- as.matrix(clust6$groups)\nshan_sf_spatialcluster <- cbind(shan_sf_cluster, as.factor(groups_mat)) %>%\n  rename(`SP_CLUSTER`=`as.factor.groups_mat.`)\nqtm(shan_sf_spatialcluster, \"SP_CLUSTER\")\n```\n\n**Hierarchial clustering VS Spatially constrained hierarchical clustering**\n\n```{r}\nhclust.map <- qtm(shan_sf_cluster,\n                  \"CLUSTER\") + \n  tm_borders(alpha = 0.5) \n\nshclust.map <- qtm(shan_sf_spatialcluster,\n                   \"SP_CLUSTER\") + \n  tm_borders(alpha = 0.5) \n\ntmap_arrange(hclust.map, shclust.map,\n             asp=NA, ncol=2)\n```\n:::\n\n<br/><br/>\n\n# **4.0 Spatially Constrained Clustering: ClustGeo Method**\n\n::: callout-note\nUsing **ClustGeo** package.\n\ndesigned to support the need of performing spatially constrained cluster analysis. More specifically, it provides a Ward-like hierarchical clustering algorithm called `hclustgeo()` including spatial/geographical constraints.\n\nIn the nutshell, the algorithm uses two dissimilarity matrices D0 and D1 along with a mixing parameter alpha, whereby the value of alpha must be a real number between \\[0, 1\\]. D0 can be non-Euclidean and the weights of the observations can be non-uniform. It gives the dissimilarities in the **attribute/clustering variable space**. D1, on the other hand, gives the dissimilarities in the **constraint space**. The criterion minimised at each stage is a convex combination of the homogeneity criterion calculated with D0 and the homogeneity criterion calculated with D1.\n\nThe idea is then to determine a value of alpha which increases the spatial contiguity without deteriorating too much the quality of the solution based on the variables of interest. This need is supported by a function called `choicealpha()`.\n:::\n\n### Ward-like hierarchical clustering: ClustGeo\n\nsimilar to hclust()\n\n```{r}\nproxmat <- read_rds(\"data/rds/proxmat.rds\")\n\nnongeo_cluster <- hclustgeo(proxmat)\nplot(nongeo_cluster, cex = 0.5)\nrect.hclust(nongeo_cluster, \n            k = 6, \n            border = 2:5)\n```\n\n::: callout-note\nNote that the dissimilarity matrix must be an object of class `dist`, i.e. an object obtained with the function `dist()`\n:::\n\n**Mapping the clusters formed**\n\n```{r}\ngroups <- as.factor(cutree(nongeo_cluster, k=6))\nshan_sf_ngeo_cluster <- cbind(shan_sf, as.matrix(groups)) %>%\n  rename(`CLUSTER` = `as.matrix.groups.`)\nqtm(shan_sf_ngeo_cluster, \"CLUSTER\")\n```\n\n**Spatially Constrained Hierarchical Clustering**\n\nBefore we can performed spatially constrained hierarchical clustering, a spatial distance matrix will be derived by using [`st_distance()`](https://r-spatial.github.io/sf/reference/geos_measures.html) of sf package.\n\n```{r}\ndist <- st_distance(shan_sf, shan_sf)\ndistmat <- as.dist(dist)\n```\n\nNext, `choicealpha()` will be used to determine a suitable value for the mixing parameter alpha as shown in the code chunk below.\n\n```{r}\ncr <- choicealpha(proxmat, distmat, range.alpha = seq(0, 1, 0.1), K=6, graph = TRUE)\n```\n\n```{r}\n# With reference to the graphs above, alpha = 0.2 will be used:\nclustG <- hclustgeo(proxmat, distmat, alpha = 0.2)\n\n# derive the cluster object\ngroups <- as.factor(cutree(clustG, k=6))\n\n# join back the group list with shan_sf polygon feature data frame\nshan_sf_Gcluster <- cbind(shan_sf, as.matrix(groups)) %>%\n  rename(`CLUSTER` = `as.matrix.groups.`)\n\nqtm(shan_sf_Gcluster, \"CLUSTER\")\n```\n\n<br/><br/>\n\n# **5.0 Visual Interpretation of Clusters**\n\n### Visualising individual clustering variable\n\n```{r}\n#| eval: false\n\n# reveal the distribution of a clustering variable (i.e RADIO_PR) by cluster\nggplot(data = shan_sf_ngeo_cluster,\n       aes(x = CLUSTER, y = RADIO_PR)) +\n  geom_boxplot()\n```\n\n![](https://r4gdsa.netlify.app/chap12_files/figure-html/unnamed-chunk-71-1.png)\n\n::: callout-note\nThe boxplot reveals Cluster 3 displays the highest mean Radio Ownership Per Thousand Household. This is followed by Cluster 2, 1, 4, 6 and 5.\n:::\n\n### Multivariate Visualisation\n\nPast studies shown that parallel coordinate plot can be used to reveal clustering variables by cluster very effectively. In the code chunk below, [`ggparcoord()`](https://ggobi.github.io/ggally/reference/ggparcoord.html) of [**GGally**](https://ggobi.github.io/ggally/index.html) package\n\n```{r}\n#| eval: false\n\nggparcoord(data = shan_sf_ngeo_cluster, \n           columns = c(17:21), \n           scale = \"globalminmax\",\n           alphaLines = 0.2,\n           boxplot = TRUE, \n           title = \"Multiple Parallel Coordinates Plots of ICT Variables by Cluster\") +\n  facet_grid(~ CLUSTER) + \n  theme(axis.text.x = element_text(angle = 30))\n```\n\n![](https://r4gdsa.netlify.app/chap12_files/figure-html/unnamed-chunk-72-1.png)\n\nThe parallel coordinate plot above reveals that households in Cluster 4 townships tend to own the highest number of TV and mobile-phone. On the other hand, households in Cluster 5 tends to own the lowest of all the five ICT.\n\nNote that the `scale` argument of `ggparcoor()` provide several methods to scale the clustering variables. They are:\n\n-   std: univariately, subtract mean and divide by standard deviation.\n\n-   robust: univariately, subtract median and divide by median absolute deviation.\n\n-   uniminmax: univariately, scale so the minimum of the variable is zero, and the maximum is one.\n\n-   globalminmax: no scaling is done; the range of the graphs is defined by the global minimum and the global maximum.\n\n-   center: use uniminmax to standardize vertical height, then center each variable at a value specified by the scaleSummary param.\n\n-   centerObs: use uniminmax to standardize vertical height, then center each variable at the value of the observation specified by the centerObsID param\n\nThere is no one best scaling method to use. You should explore them and select the one that best meet your analysis need.\n\nLast but not least, we can also compute the summary statistics such as mean, median, sd, etc to complement the visual interpretation.\n\nIn the code chunk below, `group_by()` and `summarise()` of dplyr are used to derive mean values of the clustering variables.\n\n```{r}\n#| eval: false\n\nshan_sf_ngeo_cluster %>% \n  st_set_geometry(NULL) %>%\n  group_by(CLUSTER) %>%\n  summarise(mean_RADIO_PR = mean(RADIO_PR),\n            mean_TV_PR = mean(TV_PR),\n            mean_LLPHONE_PR = mean(LLPHONE_PR),\n            mean_MPHONE_PR = mean(MPHONE_PR),\n            mean_COMPUTER_PR = mean(COMPUTER_PR))\n```\n","srcMarkdownNoYaml":"\n\n# **1.0 Overview**\n\nThis exercise focuses on using geographically referenced multivariate data to delineate homogeneous regions. Two major analyses are used:\n\n1.  Hierarchical cluster analysis\n\n2.  Spatially constrained cluster analysis\n\nThe goal is to segment Shan State, Myanmar, into homogeneous regions based on multiple Information and Communication Technology (ICT) indicators: Radio, Television, Landline phone, Mobile phone, Computer, and Internet at home. This approach is commonly applied in geobusiness and spatial policy for defining market or planning areas.\n\n<br/><br/>\n\n# **2.0 Setup**\n\n## 2.1 Installing R-Packages\n\nSpatial data handling\n\n-   **sf**, **rgdal** and **spdep**\n\nAttribute data handling\n\n-   **tidyverse**, especially **readr**, **ggplot2** and **dplyr**\n\nChoropleth mapping\n\n-   **tmap**\n\nMultivariate data visualisation and analysis\n\n-   **coorplot**, **ggpubr**, and **heatmaply**\n\nCluster analysis\n\n-   **cluster** and **ClustGeo**\n\n```{r}\npacman::p_load(spdep, tmap, sf, ClustGeo, \n               ggpubr, cluster, factoextra, NbClust,\n               heatmaply, corrplot, psych, tidyverse, GGally)\n```\n\n<br/>\n\n## 2.2 Data Acquisition\n\nTwo data sets will be used:\n\n-   `Myanmar Township Boundary Data`: a GIS data set in ESRI shapefile format. It consists of township boundary information of Myanmar. The spatial data are captured in polygon features.\n\n-   `Shan-ICT.csv`: an extract of [**The 2014 Myanmar Population and Housing Census Myanmar**](https://myanmar.unfpa.org/en/publications/2014-population-and-housing-census-myanmar-data-sheet) at the township level.\n\n::: panel-tabset\n# **Importing Geospatial Data**\n\n```{r}\nshan_sf <- st_read(dsn = \"data/geospatial\", \n                   layer = \"myanmar_township_boundaries\") %>%\n  filter(ST %in% c(\"Shan (East)\", \"Shan (North)\", \"Shan (South)\")) %>%\n  select(c(2:7))\n\nshan_sf\n\nglimpse(shan_sf)\n```\n\n# Importing Aspatial Data\n\n```{r}\nict <- read_csv (\"data/aspatial/Shan-ICT.csv\")\n\nsummary(ict)\n```\n:::\n\n<br/><br/>\n\n# **3.0 Spatially Constrained Clustering: SKATER approach**\n\n```{r}\n# Convert into SpatialPolygonsDataFrame\nshan_sp <- as_Spatial(shan_sf)\n```\n\n::: callout-note\nConvert because *`SKATER`* only supports sp obects like SpatialPolygonsDataFrame\n:::\n\n::: panel-tabset\n## Computing Neighbour List\n\n```{r}\nshan.nb <- poly2nb(shan_sp)\nsummary(shan.nb)\n```\n\n**Plot neighbours list**\n\n```{r}\ncoords <- st_coordinates(\n  st_centroid(st_geometry(shan_sf)))\n\nplot(st_geometry(shan_sf), # boundaries\n     border=grey(.5))\nplot(shan.nb, # neighbour list object, with coordinates applied to the original SpatialPolygonDataFrame (Shan state township boundaries) to extract the centroids of the polygons. These are used as the nodes for the graph representation. \n     coords, \n     col=\"blue\", \n     add=TRUE) # in order to plot the network on top of the boundaries\n```\n\n::: callout-note\nIf plot network first, some areas will be clipped.\n\nBecause the plotting area is determined by the characteristics of the first plot.\n\nIn this example, the boundary map extends further than the graph, so plot boundary first.\n:::\n\n## Computing minimum spanning tree\n\nTo calculate edge cost (distance between nodes):\n\n```{r}\nshan_ict <- read_rds(\"data/rds/shan_ict.rds\")\n\nlcosts <- nbcosts(shan.nb, shan_ict)\nhead(lcosts)\n```\n\n::: callout-note\nEach observation gives pairwise dissimilarity between its values on the 5 variables & the values for the neighbouring observation (from the neighbour list.\n\nBasically this is the notion of a generalised weight for a spatial weights matrix\n:::\n\n<br/>\n\n-   Incorporate these costs into a weighted neighbor list.\n\n-   Convert the neighbor list to a weights object using the computed `lcosts` as weights.\n\n```{r}\nshan.w <- nb2listw(shan.nb, \n                   lcosts, \n                   style=\"B\") # to make sure the cost values are not row-standardised\nsummary(shan.w)\n```\n\n## Computing minimum spanning tree\n\n-   Computed by mean of mstree()\n\n```{r}\nshan.mst <- mstree(shan.w)\nclass(shan.mst)\ndim(shan.mst)\nhead(shan.mst)\n```\n\n::: callout-note\nThe dimension is 54 not 55. Because the min spanning tree consists on n-1 edges (links) in order to traverse all the nodes\n:::\n\n**Plot MST**\n\n```{r}\nplot(st_geometry(shan_sf), \n                 border=gray(.5))\nplot.mst(shan.mst, \n         coords, \n         col=\"blue\", \n         cex.lab=0.7, \n         cex.circles=0.005, \n         add=TRUE)\n```\n\n::: callout-note\nWe can see how the initial neighbour list is simplified to just 1 edge connecting each of the nodes while passing through all the nodes\n:::\n\n## Computing spatially constrained clusters using SKATER method\n\n```{r}\nclust6 <- spdep::skater(edges = shan.mst[,1:2], \n                 data = shan_ict, \n                 method = \"euclidean\", \n                 ncuts = 5)\nstr(clust6)\n```\n\n::: callout-note\nThe *skater()* takes three mandatory arguments: - the first two columns of the MST matrix (i.e. not the cost), - the data matrix (to update the costs as units are being grouped), and - the number of cuts. Note: It is set to **one less than the number of clusters**. So, the value specified is **not** the number of clusters, but the number of cuts in the graph, one less than the number of clusters.\n\nThe most interesting component of this list structure is the groups vector containing the labels of the cluster to which each observation belongs (as before, the label itself is arbitary). This is followed by a detailed summary for each of the clusters in the edges.groups list. Sum of squares measures are given as ssto for the total and ssw to show the effect of each of the cuts on the overall criterion.\n:::\n\n**Check cluster assignment:**\n\n```{r}\nccs6 <- clust6$groups\nccs6\n\ntable(ccs6)\n```\n\n::: callout-note\nWe can find out how many observations are in each cluster by means of the table command. Parenthetially, we can also find this as the dimension of each vector in the lists contained in edges.groups. For example, the first list has node with dimension 12, which is also the number of observations in the first cluster.\n:::\n\n**Plot the pruned tree that shows 5 clusters on top of townshop area**\n\n```{r}\nplot(st_geometry(shan_sf), \n     border=gray(.5))\nplot(clust6, \n     coords, \n     cex.lab=.7,\n     groups.colors=c(\"red\",\"green\",\"blue\", \"brown\", \"pink\"),\n     cex.circles=0.005, \n     add=TRUE)\n```\n\n**Visualising the clusters in choropleth map**\n\n```{r}\nshan_sf_cluster  <- read_rds(\"data/rds/shan_sf_cluster.rds\")\n\ngroups_mat <- as.matrix(clust6$groups)\nshan_sf_spatialcluster <- cbind(shan_sf_cluster, as.factor(groups_mat)) %>%\n  rename(`SP_CLUSTER`=`as.factor.groups_mat.`)\nqtm(shan_sf_spatialcluster, \"SP_CLUSTER\")\n```\n\n**Hierarchial clustering VS Spatially constrained hierarchical clustering**\n\n```{r}\nhclust.map <- qtm(shan_sf_cluster,\n                  \"CLUSTER\") + \n  tm_borders(alpha = 0.5) \n\nshclust.map <- qtm(shan_sf_spatialcluster,\n                   \"SP_CLUSTER\") + \n  tm_borders(alpha = 0.5) \n\ntmap_arrange(hclust.map, shclust.map,\n             asp=NA, ncol=2)\n```\n:::\n\n<br/><br/>\n\n# **4.0 Spatially Constrained Clustering: ClustGeo Method**\n\n::: callout-note\nUsing **ClustGeo** package.\n\ndesigned to support the need of performing spatially constrained cluster analysis. More specifically, it provides a Ward-like hierarchical clustering algorithm called `hclustgeo()` including spatial/geographical constraints.\n\nIn the nutshell, the algorithm uses two dissimilarity matrices D0 and D1 along with a mixing parameter alpha, whereby the value of alpha must be a real number between \\[0, 1\\]. D0 can be non-Euclidean and the weights of the observations can be non-uniform. It gives the dissimilarities in the **attribute/clustering variable space**. D1, on the other hand, gives the dissimilarities in the **constraint space**. The criterion minimised at each stage is a convex combination of the homogeneity criterion calculated with D0 and the homogeneity criterion calculated with D1.\n\nThe idea is then to determine a value of alpha which increases the spatial contiguity without deteriorating too much the quality of the solution based on the variables of interest. This need is supported by a function called `choicealpha()`.\n:::\n\n### Ward-like hierarchical clustering: ClustGeo\n\nsimilar to hclust()\n\n```{r}\nproxmat <- read_rds(\"data/rds/proxmat.rds\")\n\nnongeo_cluster <- hclustgeo(proxmat)\nplot(nongeo_cluster, cex = 0.5)\nrect.hclust(nongeo_cluster, \n            k = 6, \n            border = 2:5)\n```\n\n::: callout-note\nNote that the dissimilarity matrix must be an object of class `dist`, i.e. an object obtained with the function `dist()`\n:::\n\n**Mapping the clusters formed**\n\n```{r}\ngroups <- as.factor(cutree(nongeo_cluster, k=6))\nshan_sf_ngeo_cluster <- cbind(shan_sf, as.matrix(groups)) %>%\n  rename(`CLUSTER` = `as.matrix.groups.`)\nqtm(shan_sf_ngeo_cluster, \"CLUSTER\")\n```\n\n**Spatially Constrained Hierarchical Clustering**\n\nBefore we can performed spatially constrained hierarchical clustering, a spatial distance matrix will be derived by using [`st_distance()`](https://r-spatial.github.io/sf/reference/geos_measures.html) of sf package.\n\n```{r}\ndist <- st_distance(shan_sf, shan_sf)\ndistmat <- as.dist(dist)\n```\n\nNext, `choicealpha()` will be used to determine a suitable value for the mixing parameter alpha as shown in the code chunk below.\n\n```{r}\ncr <- choicealpha(proxmat, distmat, range.alpha = seq(0, 1, 0.1), K=6, graph = TRUE)\n```\n\n```{r}\n# With reference to the graphs above, alpha = 0.2 will be used:\nclustG <- hclustgeo(proxmat, distmat, alpha = 0.2)\n\n# derive the cluster object\ngroups <- as.factor(cutree(clustG, k=6))\n\n# join back the group list with shan_sf polygon feature data frame\nshan_sf_Gcluster <- cbind(shan_sf, as.matrix(groups)) %>%\n  rename(`CLUSTER` = `as.matrix.groups.`)\n\nqtm(shan_sf_Gcluster, \"CLUSTER\")\n```\n\n<br/><br/>\n\n# **5.0 Visual Interpretation of Clusters**\n\n### Visualising individual clustering variable\n\n```{r}\n#| eval: false\n\n# reveal the distribution of a clustering variable (i.e RADIO_PR) by cluster\nggplot(data = shan_sf_ngeo_cluster,\n       aes(x = CLUSTER, y = RADIO_PR)) +\n  geom_boxplot()\n```\n\n![](https://r4gdsa.netlify.app/chap12_files/figure-html/unnamed-chunk-71-1.png)\n\n::: callout-note\nThe boxplot reveals Cluster 3 displays the highest mean Radio Ownership Per Thousand Household. This is followed by Cluster 2, 1, 4, 6 and 5.\n:::\n\n### Multivariate Visualisation\n\nPast studies shown that parallel coordinate plot can be used to reveal clustering variables by cluster very effectively. In the code chunk below, [`ggparcoord()`](https://ggobi.github.io/ggally/reference/ggparcoord.html) of [**GGally**](https://ggobi.github.io/ggally/index.html) package\n\n```{r}\n#| eval: false\n\nggparcoord(data = shan_sf_ngeo_cluster, \n           columns = c(17:21), \n           scale = \"globalminmax\",\n           alphaLines = 0.2,\n           boxplot = TRUE, \n           title = \"Multiple Parallel Coordinates Plots of ICT Variables by Cluster\") +\n  facet_grid(~ CLUSTER) + \n  theme(axis.text.x = element_text(angle = 30))\n```\n\n![](https://r4gdsa.netlify.app/chap12_files/figure-html/unnamed-chunk-72-1.png)\n\nThe parallel coordinate plot above reveals that households in Cluster 4 townships tend to own the highest number of TV and mobile-phone. On the other hand, households in Cluster 5 tends to own the lowest of all the five ICT.\n\nNote that the `scale` argument of `ggparcoor()` provide several methods to scale the clustering variables. They are:\n\n-   std: univariately, subtract mean and divide by standard deviation.\n\n-   robust: univariately, subtract median and divide by median absolute deviation.\n\n-   uniminmax: univariately, scale so the minimum of the variable is zero, and the maximum is one.\n\n-   globalminmax: no scaling is done; the range of the graphs is defined by the global minimum and the global maximum.\n\n-   center: use uniminmax to standardize vertical height, then center each variable at a value specified by the scaleSummary param.\n\n-   centerObs: use uniminmax to standardize vertical height, then center each variable at the value of the observation specified by the centerObsID param\n\nThere is no one best scaling method to use. You should explore them and select the one that best meet your analysis need.\n\nLast but not least, we can also compute the summary statistics such as mean, median, sd, etc to complement the visual interpretation.\n\nIn the code chunk below, `group_by()` and `summarise()` of dplyr are used to derive mean values of the clustering variables.\n\n```{r}\n#| eval: false\n\nshan_sf_ngeo_cluster %>% \n  st_set_geometry(NULL) %>%\n  group_by(CLUSTER) %>%\n  summarise(mean_RADIO_PR = mean(RADIO_PR),\n            mean_TV_PR = mean(TV_PR),\n            mean_LLPHONE_PR = mean(LLPHONE_PR),\n            mean_MPHONE_PR = mean(MPHONE_PR),\n            mean_COMPUTER_PR = mean(COMPUTER_PR))\n```\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"output-file":"Hands-on_Ex08.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.555","editor":"visual","theme":"cosmo","title":"Hands-on Exercise 8","subtitle":"Geographical Segmentation with Spatially Constrained Clustering Techniques (Continuation of Hands-on Exercise 7)","author":"Kai Feng","date":"Oct 19, 2024","date-modified":"last-modified"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}