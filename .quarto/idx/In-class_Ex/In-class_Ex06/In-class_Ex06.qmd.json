{"title":"In-class Exercise 6 -Global and Local Measures of Spatial Autocorrelation: sfdep methods","markdown":{"yaml":{"title":"In-class Exercise 6 -Global and Local Measures of Spatial Autocorrelation: sfdep methods","author":"kai feng","date":"Sep 23, 2024","date-modified":"last-modified","execute":{"eval":true,"echo":true,"freeze":true}},"headingText":"**1.0 Setup**","containsRefs":false,"markdown":"\n\n\n### 1.1 Installing R-Packages\n\n*`sfdep`*:\n\n-   creates an sf and tidyverse friendly interface to the package as well as introduces new functionality that is not present in spdep\n\n-   utilizes list columns extensively to make this interface possible.\n\n```{r}\npacman::p_load(sf, sfdep, spdep, tmap, tidyverse)\n```\n\n### 1.2 Data Acquisition\n\nWe will be using 2 sets of data:\n\n-   Hunan, a geospatial data set in ESRI shapefile format, and\n\n-   Hunan_2012, an attribute data set in csv format.\n\n### 1.3 Importing Hunan data\n\n::: panel-tabset\n## Hunan shapefile\n\n```{r}\nhunan_sf <- st_read(dsn = \"data/geospatial\", \n                 layer = \"Hunan\") \n```\n\n## Hunan_2012 table\n\n```{r}\nhunan2012 <- read_csv(\"data/aspatial/Hunan_2012.csv\")\nhunan2012\n```\n:::\n\n### 1.4 Data Preparation and Wrangling\n\n##### Joining Hunan and Hunan_2012\n\n```{r}\nhunan_GDPPC <- left_join(hunan_sf,hunan2012)%>%\n  select(1:4, 7, 15)\n\nhunan_GDPPC\n```\n\n### 1.5 Plot choropleth map\n\n```{r}\ntmap_mode(\"plot\")\ntm_shape(hunan_GDPPC) +\n  tm_fill(\"GDPPC\", \n          style = \"quantile\", \n          palette = \"Blues\",\n          title = \"GDPPC\") +\n  tm_layout(main.title = \"Distribution of GDP per capita by county, Hunan Province\",\n            main.title.position = \"center\",\n            main.title.size = 1.0,\n            legend.height = 0.45, \n            legend.width = 0.35,\n            frame = TRUE) +\n  tm_borders(alpha = 0.5) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_scale_bar() +\n  tm_grid(alpha =0.2)\n```\n\n<br/><br/>\n\n# **2.0 Global Measures of Spatial Association**\n\n### Step 1: Deriving Queen's Contiguity weights: sfdep methods\n\n```{r}\nwm_q <- hunan_GDPPC %>% \n  mutate(nb = st_contiguity(geometry),\n         wt = st_weights(nb,\n                         style = \"W\"),\n         .before = 1)\n\nprint(wm_q)\n```\n\n::: callout-note\n**style**:\n\n-   default 'W' (row standardized weights, sums over all links to n)\n\n-   can be 'B' (basic binary coding)\n\n-   'C'(globally standardised, sums over all links to n)\n\n-   'U' (equal C/no. of neighbours, sums over all all links to unity)\n\n-   'minmax'\n\n-   'S' (variance-stabilizing coding)\n\n**allow_zero**: if true, assigns 0 as lagged value\n\n**.before = 1** -\\> place new data to front of table\n\n**nb** -\\> a neighbor list object\n:::\n\n### Global Moran's I\n\n::: panel-tabset\n## Computing Global Moran' I\n\n```{r}\nmoranI <- global_moran(wm_q$GDPPC,\n                       wm_q$nb,\n                       wm_q$wt)\n\nglimpse(moranI)\n```\n\n## Performing Global Moran's I test\n\n```{r}\nglobal_moran_test(wm_q$GDPPC,\n                  wm_q$nb,\n                  wm_q$wt)\n```\n:::\n\n### Performing Global Moran'I permutation test\n\nUsing Monte carlo simulation\n\n::: panel-tabset\n## Step 1\n\n```{r}\nset.seed(1234)\n```\n\n## Step 2\n\n```{r}\nglobal_moran_perm(wm_q$GDPPC,\n                  wm_q$nb,\n                  wm_q$wt,\n                  nsim = 99)\n```\n\n::: callout-note\nP-value is smaller than alpha value of 0.05.\n\nHave enough statistical evidence to reject null hypo that the spatial distribution of GPD per capita are resemble random distribution (i.e. independent from spatial)\n\nBecause the Moran’s I statistics is greater than 0. We can infer that the spatial distribution shows sign of clustering.\n:::\n:::\n\n<br/><br/>\n\n# **3.0 Local Measures of Spatial Association**\n\n**LISA map**\n\n-   shows outliers & clusters.\n\n-   2 types of outliers (High-Low, Low-High)\n\n-   2 types of cluster (High-High, Low-Low)\n\n-   is an interpreted map **combining Local Moran's I & its respective P-value**\n\n### Local Moran's I, P value, LISA\n\n::: panel-tabset\n## Computing Local Moran's I\n\n```{r}\nlisa <- wm_q %>% \n  mutate(local_moran = local_moran(\n    GDPPC, nb, wt, nsim = 99),\n    .before = 1) %>% \n  unnest(local_moran)\n```\n\n## Visualising Local Moran's I VS P-value\n\n```{r}\ntmap_mode(\"plot\")\nmap1 <- tm_shape(lisa) +\n  tm_fill(\"ii\") + \n  tm_borders(alpha = 0.5) +\n  tm_view(set.zoom.limits = c(6,8)) +\n  tm_layout(main.title = \"local Moran's I of GDPPC\",\n            main.title.size = 0.8)\n\nmap2 <- tm_shape(lisa) +\n  tm_fill(\"p_ii\",\n          breaks = c(0, 0.001, 0.01, 0.05, 1),\n              labels = c(\"0.001\", \"0.01\", \"0.05\", \"Not sig\")) + \n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"p-value of local Moran's I\",\n            main.title.size = 0.8)\n\ntmap_arrange(map1, map2, ncol = 2)\n```\n\n## Visualising LISA map\n\n```{r}\nlisa_sig <- lisa  %>%\n  filter(p_ii_sim < 0.05)\ntmap_mode(\"plot\")\ntm_shape(lisa) +\n  tm_polygons() +\n  tm_borders(alpha = 0.5) +\ntm_shape(lisa_sig) +\n  tm_fill(\"mean\") + \n  tm_borders(alpha = 0.4)\n```\n:::\n\n### Hot Spot & Cold Spot Area Analysis\n\n::: panel-tabset\n## Computing local Gi\\* statistics\n\n```{r}\nwm_idw <- hunan_GDPPC %>%\n  mutate(nb = include_self(\n    st_contiguity(geometry)),\n    wts = st_inverse_distance(nb, \n                              geometry, \n                              scale = 1,\n                              alpha = 1),\n         .before = 1)\n```\n\n```{r}\nHCSA <- wm_idw %>% \n  mutate(local_Gi = local_gstar_perm(\n    GDPPC, nb, wts, nsim = 99),\n         .before = 1) %>%\n  unnest(local_Gi)\nHCSA\n```\n\n## Visualising Gi\\*\n\n```{r}\ntmap_mode(\"plot\")\ntm_shape(HCSA) +\n  tm_fill(\"gi_star\") + \n  tm_borders(alpha = 0.5) +\n  tm_view(set.zoom.limits = c(6,8))\n```\n\n## Visualising p-value of HCSA\n\n```{r}\ntmap_mode(\"plot\")\ntm_shape(HCSA) +\n  tm_fill(\"p_sim\") + \n  tm_borders(alpha = 0.5)\n```\n\n## Visualising Hot Spot & Cold Spot (HCSA)\n\n```{r}\ntmap_mode(\"plot\")\nmap1 <- tm_shape(HCSA) +\n  tm_fill(\"gi_star\") + \n  tm_borders(alpha = 0.5) +\n  tm_view(set.zoom.limits = c(6,8)) +\n  tm_layout(main.title = \"Gi* of GDPPC\",\n            main.title.size = 0.8)\n\nmap2 <- tm_shape(HCSA) +\n  tm_fill(\"p_value\",\n          breaks = c(0, 0.001, 0.01, 0.05, 1),\n              labels = c(\"0.001\", \"0.01\", \"0.05\", \"Not sig\")) + \n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"p-value of Gi*\",\n            main.title.size = 0.8)\n\ntmap_arrange(map1, map2, ncol = 2)\n\n```\n:::\n\n### Visualising hot spot and cold spot areas\n\n```{r}\nHCSA_sig <- HCSA  %>%\n  filter(p_sim < 0.05)\ntmap_mode(\"plot\")\ntm_shape(HCSA) +\n  tm_polygons() +\n  tm_borders(alpha = 0.5) +\ntm_shape(HCSA_sig) +\n  tm_fill(\"cluster\") + \n  tm_borders(alpha = 0.4)\n```\n","srcMarkdownNoYaml":"\n\n# **1.0 Setup**\n\n### 1.1 Installing R-Packages\n\n*`sfdep`*:\n\n-   creates an sf and tidyverse friendly interface to the package as well as introduces new functionality that is not present in spdep\n\n-   utilizes list columns extensively to make this interface possible.\n\n```{r}\npacman::p_load(sf, sfdep, spdep, tmap, tidyverse)\n```\n\n### 1.2 Data Acquisition\n\nWe will be using 2 sets of data:\n\n-   Hunan, a geospatial data set in ESRI shapefile format, and\n\n-   Hunan_2012, an attribute data set in csv format.\n\n### 1.3 Importing Hunan data\n\n::: panel-tabset\n## Hunan shapefile\n\n```{r}\nhunan_sf <- st_read(dsn = \"data/geospatial\", \n                 layer = \"Hunan\") \n```\n\n## Hunan_2012 table\n\n```{r}\nhunan2012 <- read_csv(\"data/aspatial/Hunan_2012.csv\")\nhunan2012\n```\n:::\n\n### 1.4 Data Preparation and Wrangling\n\n##### Joining Hunan and Hunan_2012\n\n```{r}\nhunan_GDPPC <- left_join(hunan_sf,hunan2012)%>%\n  select(1:4, 7, 15)\n\nhunan_GDPPC\n```\n\n### 1.5 Plot choropleth map\n\n```{r}\ntmap_mode(\"plot\")\ntm_shape(hunan_GDPPC) +\n  tm_fill(\"GDPPC\", \n          style = \"quantile\", \n          palette = \"Blues\",\n          title = \"GDPPC\") +\n  tm_layout(main.title = \"Distribution of GDP per capita by county, Hunan Province\",\n            main.title.position = \"center\",\n            main.title.size = 1.0,\n            legend.height = 0.45, \n            legend.width = 0.35,\n            frame = TRUE) +\n  tm_borders(alpha = 0.5) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_scale_bar() +\n  tm_grid(alpha =0.2)\n```\n\n<br/><br/>\n\n# **2.0 Global Measures of Spatial Association**\n\n### Step 1: Deriving Queen's Contiguity weights: sfdep methods\n\n```{r}\nwm_q <- hunan_GDPPC %>% \n  mutate(nb = st_contiguity(geometry),\n         wt = st_weights(nb,\n                         style = \"W\"),\n         .before = 1)\n\nprint(wm_q)\n```\n\n::: callout-note\n**style**:\n\n-   default 'W' (row standardized weights, sums over all links to n)\n\n-   can be 'B' (basic binary coding)\n\n-   'C'(globally standardised, sums over all links to n)\n\n-   'U' (equal C/no. of neighbours, sums over all all links to unity)\n\n-   'minmax'\n\n-   'S' (variance-stabilizing coding)\n\n**allow_zero**: if true, assigns 0 as lagged value\n\n**.before = 1** -\\> place new data to front of table\n\n**nb** -\\> a neighbor list object\n:::\n\n### Global Moran's I\n\n::: panel-tabset\n## Computing Global Moran' I\n\n```{r}\nmoranI <- global_moran(wm_q$GDPPC,\n                       wm_q$nb,\n                       wm_q$wt)\n\nglimpse(moranI)\n```\n\n## Performing Global Moran's I test\n\n```{r}\nglobal_moran_test(wm_q$GDPPC,\n                  wm_q$nb,\n                  wm_q$wt)\n```\n:::\n\n### Performing Global Moran'I permutation test\n\nUsing Monte carlo simulation\n\n::: panel-tabset\n## Step 1\n\n```{r}\nset.seed(1234)\n```\n\n## Step 2\n\n```{r}\nglobal_moran_perm(wm_q$GDPPC,\n                  wm_q$nb,\n                  wm_q$wt,\n                  nsim = 99)\n```\n\n::: callout-note\nP-value is smaller than alpha value of 0.05.\n\nHave enough statistical evidence to reject null hypo that the spatial distribution of GPD per capita are resemble random distribution (i.e. independent from spatial)\n\nBecause the Moran’s I statistics is greater than 0. We can infer that the spatial distribution shows sign of clustering.\n:::\n:::\n\n<br/><br/>\n\n# **3.0 Local Measures of Spatial Association**\n\n**LISA map**\n\n-   shows outliers & clusters.\n\n-   2 types of outliers (High-Low, Low-High)\n\n-   2 types of cluster (High-High, Low-Low)\n\n-   is an interpreted map **combining Local Moran's I & its respective P-value**\n\n### Local Moran's I, P value, LISA\n\n::: panel-tabset\n## Computing Local Moran's I\n\n```{r}\nlisa <- wm_q %>% \n  mutate(local_moran = local_moran(\n    GDPPC, nb, wt, nsim = 99),\n    .before = 1) %>% \n  unnest(local_moran)\n```\n\n## Visualising Local Moran's I VS P-value\n\n```{r}\ntmap_mode(\"plot\")\nmap1 <- tm_shape(lisa) +\n  tm_fill(\"ii\") + \n  tm_borders(alpha = 0.5) +\n  tm_view(set.zoom.limits = c(6,8)) +\n  tm_layout(main.title = \"local Moran's I of GDPPC\",\n            main.title.size = 0.8)\n\nmap2 <- tm_shape(lisa) +\n  tm_fill(\"p_ii\",\n          breaks = c(0, 0.001, 0.01, 0.05, 1),\n              labels = c(\"0.001\", \"0.01\", \"0.05\", \"Not sig\")) + \n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"p-value of local Moran's I\",\n            main.title.size = 0.8)\n\ntmap_arrange(map1, map2, ncol = 2)\n```\n\n## Visualising LISA map\n\n```{r}\nlisa_sig <- lisa  %>%\n  filter(p_ii_sim < 0.05)\ntmap_mode(\"plot\")\ntm_shape(lisa) +\n  tm_polygons() +\n  tm_borders(alpha = 0.5) +\ntm_shape(lisa_sig) +\n  tm_fill(\"mean\") + \n  tm_borders(alpha = 0.4)\n```\n:::\n\n### Hot Spot & Cold Spot Area Analysis\n\n::: panel-tabset\n## Computing local Gi\\* statistics\n\n```{r}\nwm_idw <- hunan_GDPPC %>%\n  mutate(nb = include_self(\n    st_contiguity(geometry)),\n    wts = st_inverse_distance(nb, \n                              geometry, \n                              scale = 1,\n                              alpha = 1),\n         .before = 1)\n```\n\n```{r}\nHCSA <- wm_idw %>% \n  mutate(local_Gi = local_gstar_perm(\n    GDPPC, nb, wts, nsim = 99),\n         .before = 1) %>%\n  unnest(local_Gi)\nHCSA\n```\n\n## Visualising Gi\\*\n\n```{r}\ntmap_mode(\"plot\")\ntm_shape(HCSA) +\n  tm_fill(\"gi_star\") + \n  tm_borders(alpha = 0.5) +\n  tm_view(set.zoom.limits = c(6,8))\n```\n\n## Visualising p-value of HCSA\n\n```{r}\ntmap_mode(\"plot\")\ntm_shape(HCSA) +\n  tm_fill(\"p_sim\") + \n  tm_borders(alpha = 0.5)\n```\n\n## Visualising Hot Spot & Cold Spot (HCSA)\n\n```{r}\ntmap_mode(\"plot\")\nmap1 <- tm_shape(HCSA) +\n  tm_fill(\"gi_star\") + \n  tm_borders(alpha = 0.5) +\n  tm_view(set.zoom.limits = c(6,8)) +\n  tm_layout(main.title = \"Gi* of GDPPC\",\n            main.title.size = 0.8)\n\nmap2 <- tm_shape(HCSA) +\n  tm_fill(\"p_value\",\n          breaks = c(0, 0.001, 0.01, 0.05, 1),\n              labels = c(\"0.001\", \"0.01\", \"0.05\", \"Not sig\")) + \n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"p-value of Gi*\",\n            main.title.size = 0.8)\n\ntmap_arrange(map1, map2, ncol = 2)\n\n```\n:::\n\n### Visualising hot spot and cold spot areas\n\n```{r}\nHCSA_sig <- HCSA  %>%\n  filter(p_sim < 0.05)\ntmap_mode(\"plot\")\ntm_shape(HCSA) +\n  tm_polygons() +\n  tm_borders(alpha = 0.5) +\ntm_shape(HCSA_sig) +\n  tm_fill(\"cluster\") + \n  tm_borders(alpha = 0.4)\n```\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"output-file":"In-class_Ex06.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.555","editor":"visual","theme":"cosmo","title":"In-class Exercise 6 -Global and Local Measures of Spatial Autocorrelation: sfdep methods","author":"kai feng","date":"Sep 23, 2024","date-modified":"last-modified"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}